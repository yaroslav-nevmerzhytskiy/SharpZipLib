apply from: 'gradleScripts/utils/commandLine.gradle'
import java.util.*

public String resolveBranch() {
    return execCommand("git rev-parse --abbrev-ref HEAD")
}

public boolean isMaster() {
    return branchMatches(/master/)
}

public boolean isRelease() {
    return branchMatches(/release.*|hotfix.*/)
}

public boolean isDevelop() {
    return branchMatches(/develop/)
}

public boolean isFeature() {
    return branchMatches(/feature.*/)
}

private boolean branchMatches(String regex) {
    return resolveBranch().replaceAll("\\s","") ==~ regex
}

private void validateRepo() {
    def status = execCommand('git status --porcelain')
    if (status) {
        throw new GradleException("Branch is not clean")
    }
}

public List getTags(boolean sorted = true) {
    def tags = []
    def tagStrs = execCommand('git --no-pager tag -l --sort=-version:refname')

    tagStrs.eachLine {
        tags.add(it)
    }

    return tags
}

public String getLatestTag() {
    def tags = getTags()
    for(String tag : tags) {
        if(tag ==~ /^(\d+\.)?(\d+\.)?(\*|\d+)$/) {
            return tag
        }
    }
    return ''
}

public String getReleaseVersion() {
    if(isRelease()) {
        def v = resolveBranch() =~ /(?!.*\/).+/
        return v.getAt(0)
    }

    return ""
}

private void checkoutBranch(String branchName) {
    execCommand("git checkout $branchName")
}

private void createBranch(String branchName) {
    execCommand("git branch $branchName")
}

private void merge(String branchName) {
    execCommand("git merge $branchName")
}

private void reset() {
    execCommand("git clean -fd")
    execCommand("git reset --hard")
}

private void push(String branchName, boolean dryRun = false) {
    println "Checking out $branchName and pushing (dryRun = $dryRun)..."
    checkoutBranch(branchName)
    if (dryRun) {
        execCommand("git push origin HEAD --tags --dry-run")
    } else {
        execCommand("git push origin HEAD --tags")
    }
}

private void pushTags(boolean dryRun = false) {
    if (dryRun) {
        execCommand("git push --tags --dry-run")
    } else {
        execCommand("git push --tags")
    }
}

private void deleteLocalTags() {
    def tags = execCommand("git tag")
    println "Deleting local tags ${tags}"
    execCommand("git tag -d ${tags}")
}

private void fetch() {
    println "Git fetch"
    execCommand("git fetch") 
}

public void cleanTags() {
    println "Cleaning git tags. This will delete all local tags and fetch the latest ones on remote."
    deleteLocalTags()
    fetch()
}

private void deleteBranch(String branchName) {
    try {
        execCommand("git push origin --delete $branchName")
    }
    catch (Throwable t) {
        println "Cannot remove remote branch: " + t
    }

    execCommand("git branch -D $branchName")
}

def verifyReleaseTag() {
    // Release version in release branch should match with tag generated by standard-version
    def releaseVersion = getReleaseVersion()
    def latestTag = getLatestTag()
    def branchName = resolveBranch()

    if (releaseVersion != latestTag) {
        throw new GradleException("Release branch '$branchName' does not match the latest tag '$latestTag'")
    }

    println "Release branch '$branchName' matches the latest tag '$latestTag'"
}

public void cutRelease(String version, boolean shouldValidateRepo) {
    if (!isDevelop()) {
        checkoutBranch('develop')
    }
    if (shouldValidateRepo) {
        validateRepo()
    }
    def branchName = 'release/' + version
    createBranch(branchName)
    checkoutBranch(branchName)
    cleanTags()
}

public void finishRelease() {
    if (!isRelease()) {
        throw new GradleException("Not on a release branch")
    }
    verifyReleaseTag()
    def releaseBranchName = resolveBranch()
    reset()
    checkoutBranch('develop')
    merge(releaseBranchName)
    checkoutBranch('master')
    merge('develop')
    pushTags(true)
    pushTags()
    push('develop', true)
    push('develop')
    push('master', true)
    push('master')
    deleteBranch(releaseBranchName)
}

public void hotfix(String version) {
    if (!isMaster()) {
        throw new GradleException("Not on a master branch")
    }
    def branchName = "hotfix/" + version
    createBranch(branchName)
    checkoutBranch(branchName)
}

ext {
    isRelease = this.isRelease()
    isDevelop = this.isDevelop()
    isFeature = this.isFeature()
    isMaster = this.isMaster()
    branchName = this.resolveBranch()
    releaseVersion = this.getReleaseVersion()
    isDeployable = isMaster || isDevelop
    latestTag = this.getLatestTag()
    cutRelease = { version, shouldValidateRepo -> this.cutRelease(version, shouldValidateRepo) }
    finishRelease = { this.finishRelease() }
    hotfix = { version -> this.hotfix(version) }
}